---
tags:
  - literature
source: https://www.youtube.com/watch?v=HlgG395PQWw
created: 2025-07-10
Type: Video
---

### üìñ Summary:
- This video explores the **functional programming paradigm**, explaining how it differs from other paradigms like **imperative** and **object-oriented programming**. It focuses on core principles such as **functions as first-class citizens**, **closures**, **immutability**, **pure functions**, and **currying**, while also touching on **real-world trade-offs**, **benefits**, and **practical use cases**. It finishes by promoting an open-source tool called **RunMe** that integrates code execution into markdown-based workflows.

### üí° Key Ideas:
- **Programming Paradigms:**
    - A paradigm is a style or philosophy of structuring code.
    - **Imperative** = "how" to do things (explicit instructions).
    - **Declarative** = "what" the goal is (functional is under this branch).

- **Functional Programming Core Concepts:**
    - **Functions as First-Class Citizens** ‚Äì Functions can be passed, returned, and stored.
    - **Closures** ‚Äì Inner functions remember the scope of their outer functions, even after the outer functions are gone.
        - Helpful analogy: _‚ÄúA closure is a poor man‚Äôs object, and an object is a poor man‚Äôs closure.‚Äù_
    - **Higher-Order Functions** ‚Äì Functions like `map()`, `filter()`, and `reduce()` that operate on other functions.
    - **Immutability & Purity** ‚Äì No side effects. Same input always gives same output.
    - **Currying** ‚Äì Splitting a function with multiple arguments into chained single-argument functions.

- **Practical Applications of Closures:**
    - Used to **encapsulate data** like objects.
    - Enable **memoization** (caching computed results).
    - Allow creation of **custom logic modules** with internal state.

- **Purely Functional Paradigm:**
    - Emphasizes **expressions**, **types**, and **referential transparency**.
    - Enables features like **lazy evaluation**, **parallelization**, and **predictable behavior**.
    - Completely avoids side effects ‚Äì leading to **harder concepts** like **monads**.

- **Why Use Functional Programming?**
    - Promotes **modularity**, **readability**, and **maintainability**.
    - Helps prevent **unexpected behavior** by restricting state changes.
    - Might have performance trade-offs and a learning curve if you're used to imperative styles.

- **Final Advice:**
    - Learn functional programming concepts even if you don‚Äôt fully adopt them.
    - Mixing paradigms is normal ‚Äì just take what‚Äôs useful for your situation.

### üó£ In my own words:
- 

### ‚û° Related permanent notes:
- 
